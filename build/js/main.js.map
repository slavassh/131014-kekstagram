{"version":3,"sources":["webpack:///webpack/bootstrap 28c6e5a7decd71d41e81","webpack:///C:/OpenServer/domains/kekstagram/src/main.js","webpack:///C:/OpenServer/domains/kekstagram/src/resizer.js","webpack:///C:/OpenServer/domains/kekstagram/src/upload.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;;;;;;;;;ACHA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,gBAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC;;;;;;;AC9UD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA,8BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA,aAAY;AACZ;AACA;;AAEA;AACA,aAAY;AACZ;AACA;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,QAAQ;AACrB,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,kDAAiD;AACjD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,MAAM;AACnB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,MAAM;AACnB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAqB,uBAAuB;AAC5C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,MAAM;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,MAAM;AACnB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 28c6e5a7decd71d41e81\n **/","'use strict';\n\nrequire('./resizer');\nrequire('./upload');\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** C:/OpenServer/domains/kekstagram/src/main.js\n ** module id = 0\n ** module chunks = 0\n **/","'use strict';\n\n(function() {\n  /**\n   * @constructor\n   * @param {string} image\n   */\n  var Resizer = function(image) {\n    // Изображение, с которым будет вестись работа.\n    this._image = new Image();\n    this._image.src = image;\n\n    // Холст.\n    this._container = document.createElement('canvas');\n    this._ctx = this._container.getContext('2d');\n\n    // Создаем холст только после загрузки изображения.\n    this._image.onload = function() {\n      // Размер холста равен размеру загруженного изображения. Это нужно\n      // для удобства работы с координатами.\n      this._container.width = this._image.naturalWidth;\n      this._container.height = this._image.naturalHeight;\n\n      /**\n       * Предлагаемый размер кадра в виде коэффициента относительно меньшей\n       * стороны изображения.\n       * @const\n       * @type {number}\n       */\n      var INITIAL_SIDE_RATIO = 0.75;\n\n      // Размер меньшей стороны изображения.\n      var side = Math.min(\n          this._container.width * INITIAL_SIDE_RATIO,\n          this._container.height * INITIAL_SIDE_RATIO);\n\n      // Изначально предлагаемое кадрирование — часть по центру с размером в 3/4\n      // от размера меньшей стороны.\n      this._resizeConstraint = new Square(\n          this._container.width / 2 - side / 2,\n          this._container.height / 2 - side / 2,\n          side);\n\n      // Отрисовка изначального состояния канваса.\n      this.setConstraint();\n    }.bind(this);\n\n    // Фиксирование контекста обработчиков.\n    this._onDragStart = this._onDragStart.bind(this);\n    this._onDragEnd = this._onDragEnd.bind(this);\n    this._onDrag = this._onDrag.bind(this);\n  };\n\n  Resizer.prototype = {\n    /**\n     * Родительский элемент канваса.\n     * @type {Element}\n     * @private\n     */\n    _element: null,\n\n    /**\n     * Положение курсора в момент перетаскивания. От положения курсора\n     * рассчитывается смещение на которое нужно переместить изображение\n     * за каждую итерацию перетаскивания.\n     * @type {Coordinate}\n     * @private\n     */\n    _cursorPosition: null,\n\n    /**\n     * Объект, хранящий итоговое кадрирование: сторона квадрата и смещение\n     * от верхнего левого угла исходного изображения.\n     * @type {Square}\n     * @private\n     */\n    _resizeConstraint: null,\n\n    /**\n     * Отрисовка канваса.\n     */\n    redraw: function() {\n      // Очистка изображения.\n      this._ctx.clearRect(0, 0, this._container.width, this._container.height);\n\n      // Параметры линии.\n      // NB! Такие параметры сохраняются на время всего процесса отрисовки\n      // canvas'a поэтому важно вовремя поменять их, если нужно начать отрисовку\n      // чего-либо с другой обводкой.\n\n      // Толщина линии.\n      this._ctx.lineWidth = 6;\n      // Цвет обводки.\n      this._ctx.strokeStyle = '#ffe753';\n      // Размер штрихов. Первый элемент массива задает длину штриха, второй\n      // расстояние между соседними штрихами.\n      this._ctx.setLineDash([15, 10]);\n      // Смещение первого штриха от начала линии.\n      this._ctx.lineDashOffset = 7;\n\n      // Сохранение состояния канваса.\n      this._ctx.save();\n\n      // Установка начальной точки системы координат в центр холста.\n      this._ctx.translate(this._container.width / 2, this._container.height / 2);\n\n      var displX = -(this._resizeConstraint.x + this._resizeConstraint.side / 2);\n      var displY = -(this._resizeConstraint.y + this._resizeConstraint.side / 2);\n      // Отрисовка изображения на холсте. Параметры задают изображение, которое\n      // нужно отрисовать и координаты его верхнего левого угла.\n      // Координаты задаются от центра холста.\n\n      this._ctx.drawImage(this._image, displX, displY);\n\n      this._ctx.fillStyle = 'rgba(0, 0, 0, .8)';\n\n      this._ctx.beginPath();\n      this._ctx.rect(displX, displY, this._container.width, this._container.height);\n      this._ctx.rect(\n        (-this._resizeConstraint.side / 2) - this._ctx.lineWidth,\n        (-this._resizeConstraint.side / 2) - this._ctx.lineWidth,\n        this._resizeConstraint.side + this._ctx.lineWidth / 2,\n        this._resizeConstraint.side + this._ctx.lineWidth / 2);\n      this._ctx.fill('evenodd');\n\n      this._ctx.strokeRect(\n          (-this._resizeConstraint.side / 2) - this._ctx.lineWidth / 2,\n          (-this._resizeConstraint.side / 2) - this._ctx.lineWidth / 2,\n          this._resizeConstraint.side - this._ctx.lineWidth / 2,\n          this._resizeConstraint.side - this._ctx.lineWidth / 2);\n\n      this._ctx.fillStyle = 'white';\n      this._ctx.font = '18px Open Sans';\n      this._ctx.textAlign = 'center';\n      this._ctx.textBaseline = 'hanging';\n      this._ctx.fillText(this._image.naturalWidth + ' x ' + this._image.naturalHeight,\n          0, -this._resizeConstraint.side / 2 - 30);\n\n      // Восстановление состояния канваса, которое было до вызова ctx.save\n      // и последующего изменения системы координат. Нужно для того, чтобы\n      // следующий кадр рисовался с привычной системой координат, где точка\n      // 0 0 находится в левом верхнем углу холста, в противном случае\n      // некорректно сработает даже очистка холста или нужно будет использовать\n      // сложные рассчеты для координат прямоугольника, который нужно очистить.\n      this._ctx.restore();\n    },\n\n    /**\n     * Включение режима перемещения. Запоминается текущее положение курсора,\n     * устанавливается флаг, разрешающий перемещение и добавляются обработчики,\n     * позволяющие перерисовывать изображение по мере перетаскивания.\n     * @param {number} x\n     * @param {number} y\n     * @private\n     */\n    _enterDragMode: function(x, y) {\n      this._cursorPosition = new Coordinate(x, y);\n      document.body.addEventListener('mousemove', this._onDrag);\n      document.body.addEventListener('mouseup', this._onDragEnd);\n    },\n\n    /**\n     * Выключение режима перемещения.\n     * @private\n     */\n    _exitDragMode: function() {\n      this._cursorPosition = null;\n      document.body.removeEventListener('mousemove', this._onDrag);\n      document.body.removeEventListener('mouseup', this._onDragEnd);\n    },\n\n    /**\n     * Перемещение изображения относительно кадра.\n     * @param {number} x\n     * @param {number} y\n     * @private\n     */\n    updatePosition: function(x, y) {\n      this.moveConstraint(\n          this._cursorPosition.x - x,\n          this._cursorPosition.y - y);\n      this._cursorPosition = new Coordinate(x, y);\n    },\n\n    /**\n     * @param {MouseEvent} evt\n     * @private\n     */\n    _onDragStart: function(evt) {\n      this._enterDragMode(evt.clientX, evt.clientY);\n    },\n\n    /**\n     * Обработчик окончания перетаскивания.\n     * @private\n     */\n    _onDragEnd: function() {\n      this._exitDragMode();\n    },\n\n    /**\n     * Обработчик события перетаскивания.\n     * @param {MouseEvent} evt\n     * @private\n     */\n    _onDrag: function(evt) {\n      this.updatePosition(evt.clientX, evt.clientY);\n    },\n\n    /**\n     * Добавление элемента в DOM.\n     * @param {Element} element\n     */\n    setElement: function(element) {\n      if (this._element === element) {\n        return;\n      }\n\n      this._element = element;\n      this._element.insertBefore(this._container, this._element.firstChild);\n      // Обработчики начала и конца перетаскивания.\n      this._container.addEventListener('mousedown', this._onDragStart);\n    },\n\n    /**\n     * Возвращает кадрирование элемента.\n     * @return {Square}\n     */\n    getConstraint: function() {\n      return this._resizeConstraint;\n    },\n\n    /**\n     * Смещает кадрирование на значение указанное в параметрах.\n     * @param {number} deltaX\n     * @param {number} deltaY\n     * @param {number} deltaSide\n     */\n    moveConstraint: function(deltaX, deltaY, deltaSide) {\n      this.setConstraint(\n          this._resizeConstraint.x + (deltaX || 0),\n          this._resizeConstraint.y + (deltaY || 0),\n          this._resizeConstraint.side + (deltaSide || 0));\n    },\n\n    /**\n     * @param {number} x\n     * @param {number} y\n     * @param {number} side\n     */\n    setConstraint: function(x, y, side) {\n      if (typeof x !== 'undefined') {\n        this._resizeConstraint.x = x;\n      }\n\n      if (typeof y !== 'undefined') {\n        this._resizeConstraint.y = y;\n      }\n\n      if (typeof side !== 'undefined') {\n        this._resizeConstraint.side = side;\n      }\n\n      requestAnimationFrame(function() {\n        this.redraw();\n        window.dispatchEvent(new CustomEvent('resizerchange'));\n      }.bind(this));\n    },\n\n    /**\n     * Удаление. Убирает контейнер из родительского элемента, убирает\n     * все обработчики событий и убирает ссылки.\n     */\n    remove: function() {\n      this._element.removeChild(this._container);\n\n      this._container.removeEventListener('mousedown', this._onDragStart);\n      this._container = null;\n    },\n\n    /**\n     * Экспорт обрезанного изображения как HTMLImageElement и исходником\n     * картинки в src в формате dataURL.\n     * @return {Image}\n     */\n    exportImage: function() {\n      // Создаем Image, с размерами, указанными при кадрировании.\n      var imageToExport = new Image();\n\n      // Создается новый canvas, по размерам совпадающий с кадрированным\n      // изображением, в него добавляется изображение взятое из канваса\n      // с измененными координатами и сохраняется в dataURL, с помощью метода\n      // toDataURL. Полученный исходный код, записывается в src у ранее\n      // созданного изображения.\n      var temporaryCanvas = document.createElement('canvas');\n      var temporaryCtx = temporaryCanvas.getContext('2d');\n      temporaryCanvas.width = this._resizeConstraint.side;\n      temporaryCanvas.height = this._resizeConstraint.side;\n      temporaryCtx.drawImage(this._image,\n          -this._resizeConstraint.x,\n          -this._resizeConstraint.y);\n      imageToExport.src = temporaryCanvas.toDataURL('image/png');\n\n      return imageToExport;\n    }\n  };\n\n  /**\n   * Вспомогательный тип, описывающий квадрат.\n   * @constructor\n   * @param {number} x\n   * @param {number} y\n   * @param {number} side\n   * @private\n   */\n  var Square = function(x, y, side) {\n    this.x = x;\n    this.y = y;\n    this.side = side;\n  };\n\n  /**\n   * Вспомогательный тип, описывающий координату.\n   * @constructor\n   * @param {number} x\n   * @param {number} y\n   * @private\n   */\n  var Coordinate = function(x, y) {\n    this.x = x;\n    this.y = y;\n  };\n\n  window.Resizer = Resizer;\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** C:/OpenServer/domains/kekstagram/src/resizer.js\n ** module id = 1\n ** module chunks = 0\n **/","/* global Resizer: true */\n\n/**\n * @fileoverview\n * @author Igor Alexeenko (o0)\n */\n\n'use strict';\n\n(function() {\n  /** @enum {string} */\n  var FileType = {\n    'GIF': '',\n    'JPEG': '',\n    'PNG': '',\n    'SVG+XML': ''\n  };\n\n  /** @enum {number} */\n  var Action = {\n    ERROR: 0,\n    UPLOADING: 1,\n    CUSTOM: 2\n  };\n\n  /**\n   * Регулярное выражение, проверяющее тип загружаемого файла. Составляется\n   * из ключей FileType.\n   * @type {RegExp}\n   */\n  var fileRegExp = new RegExp('^image/(' + Object.keys(FileType).join('|').replace('\\+', '\\\\+') + ')$', 'i');\n\n  /**\n   * @type {Object.<string, string>}\n   */\n  var filterMap;\n\n  /**\n   * Объект, который занимается кадрированием изображения.\n   * @type {Resizer}\n   */\n  var currentResizer;\n\n  /**\n   * Удаляет текущий объект {@link Resizer}, чтобы создать новый с другим\n   * изображением.\n   */\n  function cleanupResizer() {\n    if (currentResizer) {\n      currentResizer.remove();\n      currentResizer = null;\n    }\n  }\n\n  /**\n   * Ставит одну из трех случайных картинок на фон формы загрузки.\n   */\n  function updateBackground() {\n    var images = [\n      'img/logo-background-1.jpg',\n      'img/logo-background-2.jpg',\n      'img/logo-background-3.jpg'\n    ];\n\n    var backgroundElement = document.querySelector('.upload');\n    var randomImageNumber = Math.round(Math.random() * (images.length - 1));\n    backgroundElement.style.backgroundImage = 'url(' + images[randomImageNumber] + ')';\n  }\n\n  /**\n   * Проверяет, валидны ли данные, в форме кадрирования.\n   * @return {boolean}\n   */\n  function resizeFormIsValid() {\n    return true;\n  }\n\n  /**\n   * Форма загрузки изображения.\n   * @type {HTMLFormElement}\n   */\n  var uploadForm = document.forms['upload-select-image'];\n\n  /**\n   * Форма кадрирования изображения.\n   * @type {HTMLFormElement}\n   */\n  var resizeForm = document.forms['upload-resize'];\n\n  /**\n   * Форма добавления фильтра.\n   * @type {HTMLFormElement}\n   */\n  var filterForm = document.forms['upload-filter'];\n\n  /**\n   * @type {HTMLImageElement}\n   */\n  var filterImage = filterForm.querySelector('.filter-image-preview');\n\n  /**\n   * @type {HTMLElement}\n   */\n  var uploadMessage = document.querySelector('.upload-message');\n\n  /**\n   * @param {Action} action\n   * @param {string=} message\n   * @return {Element}\n   */\n  function showMessage(action, message) {\n    var isError = false;\n\n    switch (action) {\n      case Action.UPLOADING:\n        message = message || 'Кексограмим&hellip;';\n        break;\n\n      case Action.ERROR:\n        isError = true;\n        message = message || 'Неподдерживаемый формат файла<br> <a href=\"' + document.location + '\">Попробовать еще раз</a>.';\n        break;\n    }\n\n    uploadMessage.querySelector('.upload-message-container').innerHTML = message;\n    uploadMessage.classList.remove('invisible');\n    uploadMessage.classList.toggle('upload-message-error', isError);\n    return uploadMessage;\n  }\n\n  function hideMessage() {\n    uploadMessage.classList.add('invisible');\n  }\n\n  /**\n   * Обработчик изменения изображения в форме загрузки. Если загруженный\n   * файл является изображением, считывается исходник картинки, создается\n   * Resizer с загруженной картинкой, добавляется в форму кадрирования\n   * и показывается форма кадрирования.\n   * @param {Event} evt\n   */\n  uploadForm.onchange = function(evt) {\n    var element = evt.target;\n    if (element.id === 'upload-file') {\n      // Проверка типа загружаемого файла, тип должен быть изображением\n      // одного из форматов: JPEG, PNG, GIF или SVG.\n      if (fileRegExp.test(element.files[0].type)) {\n        var fileReader = new FileReader();\n\n        showMessage(Action.UPLOADING);\n\n        fileReader.onload = function() {\n          cleanupResizer();\n\n          currentResizer = new Resizer(fileReader.result);\n          currentResizer.setElement(resizeForm);\n          uploadMessage.classList.add('invisible');\n\n          uploadForm.classList.add('invisible');\n          resizeForm.classList.remove('invisible');\n\n          hideMessage();\n        };\n\n        fileReader.readAsDataURL(element.files[0]);\n      } else {\n        // Показ сообщения об ошибке, если формат загружаемого файла не поддерживается\n        showMessage(Action.ERROR);\n      }\n    }\n  };\n\n  /**\n   * Обработка сброса формы кадрирования. Возвращает в начальное состояние\n   * и обновляет фон.\n   * @param {Event} evt\n   */\n  resizeForm.onreset = function(evt) {\n    evt.preventDefault();\n\n    cleanupResizer();\n    updateBackground();\n\n    resizeForm.classList.add('invisible');\n    uploadForm.classList.remove('invisible');\n  };\n\n  /**\n   * Обработка отправки формы кадрирования. Если форма валидна, экспортирует\n   * кропнутое изображение в форму добавления фильтра и показывает ее.\n   * @param {Event} evt\n   */\n  resizeForm.onsubmit = function(evt) {\n    evt.preventDefault();\n\n    if (resizeFormIsValid()) {\n      var image = currentResizer.exportImage().src;\n\n      var thumbnails = filterForm.querySelectorAll('.upload-filter-preview');\n      for (var i = 0; i < thumbnails.length; i++) {\n        thumbnails[i].style.backgroundImage = 'url(' + image + ')';\n      }\n\n      filterImage.src = image;\n\n      resizeForm.classList.add('invisible');\n      filterForm.classList.remove('invisible');\n    }\n  };\n\n  /**\n   * Сброс формы фильтра. Показывает форму кадрирования.\n   * @param {Event} evt\n   */\n  filterForm.onreset = function(evt) {\n    evt.preventDefault();\n\n    filterForm.classList.add('invisible');\n    resizeForm.classList.remove('invisible');\n  };\n\n  /**\n   * Отправка формы фильтра. Возвращает в начальное состояние, предварительно\n   * записав сохраненный фильтр в cookie.\n   * @param {Event} evt\n   */\n  filterForm.onsubmit = function(evt) {\n    evt.preventDefault();\n\n    cleanupResizer();\n    updateBackground();\n\n    filterForm.classList.add('invisible');\n    uploadForm.classList.remove('invisible');\n  };\n\n  /**\n   * Обработчик изменения фильтра. Добавляет класс из filterMap соответствующий\n   * выбранному значению в форме.\n   */\n  filterForm.onchange = function() {\n    if (!filterMap) {\n      // Ленивая инициализация. Объект не создается до тех пор, пока\n      // не понадобится прочитать его в первый раз, а после этого запоминается\n      // навсегда.\n      filterMap = {\n        'none': 'filter-none',\n        'chrome': 'filter-chrome',\n        'sepia': 'filter-sepia',\n        'marvin': 'filter-marvin'\n      };\n    }\n\n    var selectedFilter = [].filter.call(filterForm['upload-filter'], function(item) {\n      return item.checked;\n    })[0].value;\n\n    // Класс перезаписывается, а не обновляется через classList потому что нужно\n    // убрать предыдущий примененный класс. Для этого нужно или запоминать его\n    // состояние или просто перезаписывать.\n    filterImage.className = 'filter-image-preview ' + filterMap[selectedFilter];\n  };\n\n  cleanupResizer();\n  updateBackground();\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** C:/OpenServer/domains/kekstagram/src/upload.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}